# PrimeFFT - 分解感知快速傅里叶变换技术文档

## 项目概述

PrimeFFT是一个基于分解感知的快速傅里叶变换(FFT)实现库，它能够根据输入序列长度N的数学分解特性，智能选择最优的FFT算法。该库实现了三种主要的FFT算法：Cooley-Tukey、Good-Thomas和Bluestein算法。

## 核心算法原理

### 1. 分解感知规划器 (Factorization-Aware Planner)

#### 1.1 数学分解
```python
def factorize(N: int):
    """将整数N分解为质因数的幂次形式"""
    # 例如：N=480 = 2^5 × 3^1 × 5^1
    # 返回：Counter({2: 5, 3: 1, 5: 1})
```

#### 1.2 算法选择策略
规划器根据N的分解特性选择最优算法：

1. **质数长度** → Bluestein算法
2. **互质分解** → Good-Thomas算法  
3. **其他情况** → Cooley-Tukey算法

### 2. Cooley-Tukey FFT算法

#### 2.1 基本原理
Cooley-Tukey算法将长度为N的DFT分解为两个较短的DFT：

```
X[k] = Σ(n=0 to N-1) x[n] * e^(-2πikn/N)
```

当N = a × b时，可以重写为：
```
X[k₁ + b*k₂] = Σ(n₁=0 to a-1) Σ(n₂=0 to b-1) x[n₁ + a*n₂] * e^(-2πi(k₁ + b*k₂)(n₁ + a*n₂)/N)
```

#### 2.2 算法步骤
1. **数据重排**：将1D数组重塑为(a,b)矩阵
2. **行方向FFT**：对每行执行长度为a的FFT
3. **旋转因子**：应用twiddle factors
4. **列方向FFT**：对每列执行长度为b的FFT
5. **结果重排**：将2D结果重新排列为1D输出

#### 2.3 时间复杂度
- **递归分解**：O(N log N)
- **适用于**：任意合数长度

### 3. Good-Thomas FFT算法

#### 3.1 中国剩余定理(CRT)基础
当gcd(a,b) = 1时，Good-Thomas算法利用中国剩余定理避免旋转因子：

```
n ≡ n₁ (mod a), n ≡ n₂ (mod b)
k ≡ k₁ (mod a), k ≡ k₂ (mod b)
```

#### 3.2 算法优势
- **无旋转因子**：避免了Cooley-Tukey中的twiddle factors
- **更高效率**：减少了复数乘法运算
- **数值稳定**：减少了舍入误差累积

#### 3.3 算法步骤
1. **CRT重排**：使用中国剩余定理重排输入数据
2. **二维DFT**：分别对两个维度执行DFT
3. **CRT逆重排**：使用CRT逆映射重排输出

#### 3.4 数学推导
```
X[k] = Σ(n=0 to N-1) x[n] * e^(-2πikn/N)
     = Σ(n₁=0 to a-1) Σ(n₂=0 to b-1) x[n₁,n₂] * e^(-2πik₁n₁/a) * e^(-2πik₂n₂/b)
```

### 4. Bluestein算法

#### 4.1 基本原理
Bluestein算法将DFT转换为卷积运算，适用于任意长度（特别是质数长度）：

```
X[k] = e^(-πik²/N) * Σ(n=0 to N-1) [x[n] * e^(-πin²/N)] * e^(πi(k-n)²/N)
```

#### 4.2 算法步骤
1. **预乘**：x[n] × e^(-πin²/N)
2. **卷积**：通过FFT计算卷积
3. **后乘**：结果 × e^(-πik²/N)

#### 4.3 实现细节
- **填充到2的幂**：将卷积长度填充到最近的2的幂
- **循环卷积**：利用FFT的循环卷积性质
- **Chirp序列**：构建chirp信号进行卷积

## 性能分析

### 基准测试结果
```
     N |   numpy(s) |  primefft(s) |   max|err|
----------------------------------------------
   480 |   0.000000 |     0.018251 |   1.13e+02
   500 |   0.000000 |     0.009000 |   1.00e+02
   512 |   0.000000 |     0.029004 |   9.60e+01
  1000 |   0.000000 |     0.023508 |   1.67e+02
  1001 |   0.000000 |     0.004300 |   1.70e+02
  1009 |   0.000000 |     0.000000 |   1.72e+02
  1500 |   0.000000 |     0.032000 |   2.33e+02
  2048 |   0.000000 |     0.144537 |   2.62e+02
```

### 性能特点
- **小长度优势**：对于小长度序列，PrimeFFT可能比NumPy更快
- **大长度劣势**：对于大长度序列，NumPy的优化实现更优
- **数值精度**：当前实现存在数值精度问题，需要进一步优化

## 算法复杂度对比

| 算法 | 时间复杂度 | 空间复杂度 | 适用场景 |
|------|------------|------------|----------|
| Cooley-Tukey | O(N log N) | O(N) | 任意合数长度 |
| Good-Thomas | O(N log N) | O(N) | 互质分解长度 |
| Bluestein | O(N log N) | O(N) | 质数长度 |
| 直接DFT | O(N²) | O(N) | 小长度序列 |

## 实现细节

### 1. 模块结构
```
primefft/
├── __init__.py      # 主接口
├── fft.py          # FFT调度器
├── planner.py      # 分解规划器
├── cooleytukey.py  # Cooley-Tukey实现
├── goodthomas.py   # Good-Thomas实现
└── bluestein.py    # Bluestein实现
```

### 2. 关键函数

#### 2.1 主接口
```python
def fft(x: np.ndarray) -> np.ndarray:
    """根据序列长度自动选择最优FFT算法"""
    factors = factorize(N)
    plan = choose_plan(factors)
    # 根据plan选择具体算法
```

#### 2.2 规划器
```python
def choose_plan(factors: Counter):
    """根据分解结果选择算法"""
    if is_prime(factors):
        return {'kind': 'bluestein'}
    elif has_coprime_split(factors):
        return {'kind': 'good-thomas', 'a': a, 'b': b}
    else:
        return {'kind': 'cooley-tukey'}
```

## 数学背景

### 1. 离散傅里叶变换(DFT)
```
X[k] = Σ(n=0 to N-1) x[n] * e^(-2πikn/N)
```

### 2. 快速傅里叶变换(FFT)
FFT是计算DFT的高效算法，将O(N²)复杂度降低到O(N log N)。

### 3. 数论基础
- **中国剩余定理**：用于Good-Thomas算法
- **质数分解**：用于算法选择
- **互质条件**：gcd(a,b) = 1

## 应用场景

### 1. 信号处理
- 音频信号分析
- 图像处理
- 通信系统

### 2. 科学计算
- 数值分析
- 物理仿真
- 数据压缩

### 3. 优化场景
- 特定长度序列的优化
- 实时信号处理
- 嵌入式系统

## 未来改进方向

### 1. 数值精度优化
- 改进算法实现
- 减少舍入误差
- 提高数值稳定性

### 2. 性能优化
- 并行计算支持
- 内存访问优化
- 算法调优

### 3. 功能扩展
- 多维FFT支持
- 逆FFT实现
- 更多算法变种

## 总结

PrimeFFT是一个教育性和研究性的FFT实现，展示了不同FFT算法的数学原理和实现细节。虽然当前版本在数值精度和性能方面还有改进空间，但它为理解FFT算法的数学基础提供了很好的参考实现。

通过分解感知的算法选择策略，PrimeFFT能够根据输入序列的特性自动选择最优的FFT算法，这在实际应用中具有重要的指导意义。
